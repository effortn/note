数据库设计目标：
	1）减少数据冗余
	2）避免数据维护异常(插入异常、更新异常、删除异常)
	3）结约存储空间
	4）高效的访问

数据库设计步骤：
	需求分析 ---> 逻辑设计 ---> 物理设计 ---> 维护优化

1、需求分析：
	1）了解系统中所要存储的数据：数据是什么，数据有哪些属性，数据和属性各自的特点有哪些
	2）了解数据的存储特点：例如时效性数据(过期清理、归档)
	3）了解数据的生命周期：例如增长快、数据量大、非核心数据(分库分表)，日志不适合存库(DBA角度，制定归档计划)
	需要了解的一些问题：
		1）实体及实体之间的关系（1对1,1对多，多对多）
		2）实体所包含的属性有什么？
		3）那些属性或属性的组合可以唯一标识一个实体

2、逻辑设计：使用ER图对数据库进行逻辑建模
	1）将需求转化为数据库的逻辑模型
	2）通过ER图的形式对逻辑模型进行展示
		ER图概念：关系(表)、元组(表中的一行)、属性(表中的一列)、候选码(表中的某个属性组，可以唯一确定一个元组)、
				 主码(一个关系有多个候选码，选定其中一个为主码)、域(属性的取值范围)、分量(元组中的一个属性值)
		ER图例：矩形(表示实体集，矩形内写实体集的名字)、菱形(表示联系集)、椭圆(表示实体的属性)、线段(连接)
	3）同所选的具体的DBMS系统无关
	设计遵循范式：
		1）第一范式：数据库表中的所有字段都是单一属性，不可再分的。这个单一属性是由基本的数据类型所构成的，
					如整数，浮点数，字符串，等；换句话说，第一范式要求数据库中的表都是二维表
		2）第二范式：数据库的表中不存在非关键字段对任一候选关键字段的部分函数依赖。
					部分函数依赖是指存在着组合关键字中的某一关键字决定非关键字的情况。
					换句话说：所有单关键字段的表都符合第二范式
		3）第三范式：第三范式是在第二范式的基础之上定义的，如果数据表中不存在非关键字段对任意候选关键字段的
					传递函数依赖则符合第三范式。
		4）BC范式 ：在第三范式的基础之上数据库表中如果不存在任何字段对任一候选字段的传递函数依赖则符合BC范式。
					也就是说如果是复合关键字，则复合关键字之间也不能存在函数依赖关系。

3、物理设计：根据数据库自身的特点把逻辑设计转换为物理设计
	1）选择合适的数据库管理系统(Oracle、 MySQL、 SQLServer及PgSQL)
		Oracle：商业数据库(成本高)、事务成本低(企业级项目)、扩展容易、更安全
		MySQL：开源数据库、事务成本较高(适用于互联网项目)
		MySQL存储引擎：
								事务				锁粒度					主要应用					忌用
			MyISAM 		  	   不支持      支持并发插入的表级锁		select，insert		   读写操作频繁 
			MRG_MYISAM	  	   不支持	   支持并发插入的表级锁		分段归档，数据仓库   	 全局查找过多的场景
			Innodb		  	 	支持 		支持MVCC的行级锁 				事务处理					无	
			Archive(存储更小)   不支持			行级锁		日志记录，只支持insert、select	   需要随机读写删
			Ndb cluster			支持 			行级锁					高可用性				大部分应用
	2）定义数据库、表及字段的命名规范
		1>可读性原则 --> 使用大小写格式化库对象名字以获得良好可读性
		2>表意性原则	--> 对象的名字应该能够描述它所标识的对象
		3>长名性原则 --> 尽可能少使用或者不适用缩写，适用数据库(DATABASE)名之外的任一对象
	3）根据所选的DBMS系统选择合适的字段类型
			列的数据类型一方面影响数据存储空间的开销，另一方面也会影响数据查询性能。当一个列可以选择多种数据类型时，
		应该优先考虑数字类型，其次是日期或二进制类型，最后是字符类型。对于相同级别的数据类型，应该优先选择占用空间小
		的数据类型。
		MySQL字段类型占用空间(字节数)：
			TINYINT(1), SMALLINT(2), MEDIUMINT(3), INT(4), BIGINT(8), DATE(3), DATETIME(8), TIMESTAMP(4),
			CHAR(M)(M, 1 <= M <= 255), VARCHAR(M)(L+1字节, L <= M和1 <= M <= 255)
		1> 在数据进行比较(查询条件、JOIN条件及排序)操作时：同样的数据，字符处理往往比数字处理慢
		2> 在数据库中，数据处理以页为单位，列的长度越小，利于性能提升(I/O瓶颈)
		3> char与varchar如何选择
			| 如果列中要存储的数据长度差不多是一致的，则应该考虑用char；否则应该考虑用varchar
			| 如果列中的最大数据长度小于50Byte，则一般也考虑用char。
				(如果这个列很少用，则基于节省空间和减少I/O的考虑，还是可以选择用varchar)
			| 一般不宜定义大于50Byte的char类型列
		4> decimal与float如何选择
			| decimal用于存储精确数据，而float只能用于存储非精确数据。故精确数据只能选用decimal类型
			| 由于float的存储空间开销一般比decimal小，故非精确数据优先选择float类型
		5> 时间类型如何存储
			| 使用int来存储时间字段的优缺点
				优点：字段长度比datetime小
				缺点：使用不方便，要进行函数转换
				限制：只能存储到2028-1-19 11:14:07即2的32次方
			| 需要存储的时间粒度
				年 月 日 小时 分 秒 周
		6> 如何选择主键
			| 区分业务主键和数据库主键
			| 跟据数据库的类型，考虑主键是否要顺序增长
			| 主键的字段类型所占空间要尽可能的小
		7> 避免使用外键约束
			| 降低数据导入的效率
			| 增加维护成本
			| 虽然不建议使用外键约束，但是相关联的列上一定要建立索引
		8> 避免使用触发器
			| 降低数据导入的效率
			| 可能会出现意想不到的数据异常
			| 使业务逻辑变得复杂
		9> 关于预留字段
			| 无法准确的知道预留字段的类型
			| 无法准确的知道预留字段中所存储的内容
			| 后期维护预留字段所要的成本，同增加一个字段所需要的成本是相同的
			| 严禁使用预留字段
	4）反范式化设计
		反范式化是针对范式化而言的，是为了性能和读取效率的考虑而适当的对第三范式的要求进行违反，而允许存在少量的数据冗余
		反范式化就是使用空间来换取时间。
		1> 减少表的关联数量
		2> 增加数据的读取效率
		3> 反范式化一定要适度

4、维护优化：
	1）新的需求进行建表
	2）索引优化
	3）大表拆分
	具体优化维护：
		1）维护数据字典
			1> 使用第三方工具对数据字典进行维护
			2> 利用数据库本身的备注字段来维护数据字典(comment)
		2）维护索引
			1> 建立索引的列：
				| 出现在WHERE从句，GROUP BY从句，ORDER BY从句中的列
				| 可选择性高的列要放在索引的前面
				| 索引中不要包括太长的数据类型
			2> 注意事项：
				| 索引并不是越多越好，过多的索引不但会降低写效率，而且会降低读的效率
				| 定期维护索引碎片
				| 在SQL语句中不要使用强制索引关键字
		3）维护表结构
			1> 注意事项
				| 使用在线变更表结构的工具(MySQL5.6之后本身支持在线表结构的变更)
				| 同时对数据字典进行维护
				| 控制表的宽度和大小
			2> 数据库的适合操作
				| 批量操作 VS 逐条操作
				| 禁止使用 select * 这样的查询
				| 控制使用用户自定义函数(使用函数的列索引会失效)
				| 不要使用数据库中的全文索引
		4）在适当的时候对表进行水平拆分或垂直拆分
			1> 为了控制表的宽度可以进行表的垂直拆分
				| 经常一起查询的列放在一起
				| text，blob等大字段拆分出到附加表
			2> 为了控制表的大小可以进行表的水平拆分
				| 通过主键Hash Key